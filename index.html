<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>불법주정차 민원 히트맵 · 시간필터 + 실시간 위치 + 근접 알림 (v-proximity)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    html, body { height:100%; margin:0; }
    #map { height:100vh; }

    /* 상단 컨트롤 바 */
    .controls {
      position: absolute; z-index: 1000; left: 8px; top: 8px;
      background: rgba(255,255,255,.95); padding: 8px 10px; border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,.15); font-size: 13px; line-height: 1.4;
    }
    .controls label { margin-right: 8px; }
    .controls select, .controls input[type="range"], .controls input[type="number"] { vertical-align: middle; }

    /* 하단 HUD */
    .hud {
      position: absolute; z-index: 1000; left: 8px; bottom: 8px;
      background: rgba(0,0,0,.6); color: #fff; padding: 6px 8px; border-radius: 6px;
      font-size: 12px; line-height: 1.4; max-width: 70vw;
    }

    /* 우상단 배지/상태 */
    .badge {
      position: absolute; z-index: 1000; right: 8px; top: 8px;
      background: #111; color:#fff; padding:4px 8px; border-radius: 6px; font-size: 12px; opacity:.85;
    }
    .status {
      position:absolute; z-index:1000; right:8px; top:44px;
      background: rgba(255,255,255,.95); padding:6px 8px; border-radius:6px; font-size:12px;
      box-shadow: 0 2px 6px rgba(0,0,0,.1);
    }

    /* 화면 상단 경고 배너 */
    .alert {
      position: absolute; z-index: 1200; left: 50%; top: 50px; transform: translateX(-50%);
      background: #ff4d4f; color:#fff; padding:10px 14px; border-radius:10px; font-weight:700;
      box-shadow: 0 4px 12px rgba(0,0,0,.25); display:none;
    }

    /* 스위치형 체크박스 */
    .switch { position: relative; display: inline-block; width: 42px; height: 24px; vertical-align: middle; }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
      background-color: #ccc; transition: .2s; border-radius: 24px; }
    .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px;
      background-color: white; transition: .2s; border-radius: 50%; }
    .switch input:checked + .slider { background-color: #4caf50; }
    .switch input:checked + .slider:before { transform: translateX(18px); }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- 상단: 요일·시간 + 근접 알림 UI -->
  <div class="controls">
    <div style="margin-bottom:6px;">
      <label>요일
        <select id="dowSel">
          <option value="all">전체</option>
          <option value="0">월</option><option value="1">화</option><option value="2">수</option>
          <option value="3">목</option><option value="4">금</option><option value="5">토</option><option value="6">일</option>
        </select>
      </label>
      <label>시간
        <input id="hourRange" type="range" min="0" max="23" step="1" value="9" />
        <span id="hourLabel">09시</span>
        <label style="margin-left:6px;"><input id="allHours" type="checkbox" /> 전체시간</label>
      </label>
    </div>
    <div>
      <span style="margin-right:6px;">근접 알림</span>
      <label class="switch">
        <input id="alertToggle" type="checkbox" checked />
        <span class="slider"></span>
      </label>
      <label style="margin-left:10px;">반경
        <select id="radiusSel">
          <option value="50">50m</option>
          <option value="100" selected>100m</option>
          <option value="150">150m</option>
          <option value="200">200m</option>
        </select>
      </label>
      <label style="margin-left:8px;">임계치
        <input id="thresInp" type="number" min="1" max="50" step="1" value="5" style="width:56px;" />
      </label>
      <button id="testBtn" style="margin-left:8px;">테스트</button>
    </div>
  </div>

  <!-- 배지/상태/경고 -->
  <div class="badge">v-proximity</div>
  <div class="status" id="status">로드 준비…</div>
  <div class="alert" id="alertBox">⚠ 근접 위험 구역!</div>

  <!-- 좌하단: 위치 HUD -->
  <div class="hud" id="hud">GPS 대기중…</div>

  <!-- Scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    // ───────── 0) 지도
    const map = L.map('map');
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 20, attribution: '&copy; OpenStreetMap contributors' }).addTo(map);
    map.setView([36.64, 127.49], 12);

    // UI 요소
    const dowSel = document.getElementById('dowSel');
    const hourRange = document.getElementById('hourRange');
    const hourLabel = document.getElementById('hourLabel');
    const allHoursChk = document.getElementById('allHours');
    const statusBox = document.getElementById('status');

    const alertToggle = document.getElementById('alertToggle');
    const radiusSel = document.getElementById('radiusSel');
    const thresInp = document.getElementById('thresInp');
    const alertBox = document.getElementById('alertBox');
    const testBtn = document.getElementById('testBtn');

    // ───────── 1) CSV 후보 경로
    const rawCandidates = [
      '지오코딩결과_전체 (1).csv',
      '지오코딩결과_전체.csv',
      'geocoded.csv',
      'data/geocoded.csv'
    ];
    const candidates = rawCandidates.map(p => {
      let pth = location.pathname; if (!pth.endsWith('/')) pth = pth.replace(/\/[^/]*$/, '/');
      return location.origin + pth + encodeURI(p) + '?v=' + Date.now();
    });

    // ───────── 2) 컬럼 탐지/날짜 파서
    const LAT_KEYS = ['위도','lat','latitude','Lat','Latitude','Y','y'];
    const LON_KEYS = ['경도','lon','longitude','Lon','Longitude','X','x'];
    const DATE_KEYS = ['단속일시','발생일시','신고일시','일시','date','Date','datetime','Datetime'];

    function findKey(keys, header) {
      const lower = header.map(h => (h||'').toString().trim().toLowerCase());
      for (const k of keys) { const i = lower.indexOf(k.toLowerCase()); if (i !== -1) return header[i]; }
      for (const h of header) { const L=(h||'').toString().trim().toLowerCase(); for (const k of keys) if (L.includes(k.toLowerCase())) return h; }
      return null;
    }
    function toNum(v){ if (typeof v==='number') return v; if (v==null) return NaN; const s=v.toString().trim().replace(/[, ]/g,''); return s?Number(s):NaN; }

    function parseDateLoose(val){
      if(!val) return null; let s=String(val).trim();
      const hasPM=/오후|PM/i.test(s), hasAM=/오전|AM/i.test(s);
      s=s.replace(/[./]/g,'-').replace(/[오전오후AMPMapm]/g,'').trim();
      const nums=s.match(/\d+/g); if(!nums||nums.length<3){ const d=new Date(val); return isNaN(d)?null:d; }
      let [Y,M,D,h=0,m=0,s2=0]=nums.map(n=>parseInt(n,10));
      if (hasPM && h<12) h+=12; if (hasAM && h===12) h=0;
      const d=new Date(Y,(M||1)-1,D||1,h,m,s2); return isNaN(d)?null:d;
    }
    function getMon0Dow(d){ return (d.getDay()+6)%7; } // Mon=0..Sun=6
    function pad2(n){ return (n<10?'0':'')+n; }

    // ───────── 3) 데이터 적재
    let heatLayer=null;
    const pointsByHOW=Array.from({length:168},()=>[]);
    let allPoints=[];           // [lat, lon, 1]
    let activePoints=[];        // 현재 화면에 걸리는 포인트 셋(필터 반영)
    let alertCircle=null;       // 반경 표시 원
    let lastAlertAt=0;          // 경고 쿨다운

    async function loadCSV(){
      for(const url of candidates){
        try{
          statusBox.textContent='CSV 로드 중: '+decodeURI(url);
          const res=await new Promise((resolve,reject)=>{ Papa.parse(url,{header:true,download:true,skipEmptyLines:true,complete:resolve,error:reject}); });
          if(!res || !res.data || res.data.length===0) continue;

          const header=res.meta&&res.meta.fields?res.meta.fields:Object.keys(res.data[0]||{});
          const latKey=findKey(LAT_KEYS,header);
          const lonKey=findKey(LON_KEYS,header);
          const dateKey=findKey(DATE_KEYS,header);
          statusBox.textContent=`컬럼 인식 → 위도: ${latKey||'-'}, 경도: ${lonKey||'-'}, 일시: ${dateKey||'-'}`;
          if(!latKey||!lonKey){ console.warn('위경도 미인식', header); continue; }

          for(let i=0;i<168;i++) pointsByHOW[i]=[];
          allPoints=[];

          let valid=0, dated=0;
          for(const row of res.data){
            const lat=toNum(row[latKey]), lon=toNum(row[lonKey]);
            if(!Number.isFinite(lat)||!Number.isFinite(lon)||Math.abs(lat)>90||Math.abs(lon)>180) continue;
            const p=[lat,lon,1]; allPoints.push(p); valid++;
            if(dateKey && row[dateKey]){
              const d=parseDateLoose(row[dateKey]);
              if(d){ const how=getMon0Dow(d)*24 + d.getHours(); pointsByHOW[how].push(p); dated++; }
            }
          }

          // 초기: 전체시간 렌더
          renderHeat('all', 9);
          enableFilters(dated>0);

          console.log('CSV OK', {records:valid, withDatetime:dated, latKey, lonKey, dateKey});
          return;
        }catch(e){ console.warn('CSV 로드 실패:', url, e); }
      }
      statusBox.textContent='CSV를 찾지 못했습니다.';
      alert('CSV를 찾지 못했거나, 위도/경도 컬럼을 인식하지 못했습니다.\n파일명을 "지오코딩결과_전체 (1).csv" 또는 "geocoded.csv"로 업로드했는지 확인하세요.');
    }

    function enableFilters(hasDate){
      dowSel.disabled = !hasDate;
      hourRange.disabled = !hasDate;
      allHoursChk.checked = !hasDate; // 날짜 없으면 전체시간 고정
    }

    // ───────── 4) 히트맵 + 활성 포인트 갱신
    function renderHeat(dowValue, hourValue){
      // 활성 포인트 선정
      if(allHoursChk.checked || dowValue==='all'){ activePoints = allPoints; }
      else {
        const how=parseInt(dowValue,10)*24 + parseInt(hourValue,10);
        activePoints = pointsByHOW[how] || [];
      }

      // 히트맵 갱신
      if(heatLayer) map.removeLayer(heatLayer);
      if(activePoints.length>0){
        heatLayer=L.heatLayer(activePoints,{radius:18,blur:15,maxZoom:18}).addTo(map);
        const bounds=L.latLngBounds(activePoints.map(p=>L.latLng(p[0],p[1])));
        map.fitBounds(bounds,{padding:[20,20]});
        statusBox.textContent=`표시 포인트: ${activePoints.length}개`;
      }else{
        statusBox.textContent='선택 조건에 해당하는 포인트가 없습니다.';
      }

      // 경계 표시 원 초기화
      if(alertCircle){ map.removeLayer(alertCircle); alertCircle=null; }
    }

    function updateHourLabel(){ hourLabel.textContent=pad2(parseInt(hourRange.value,10))+'시'; }

    dowSel.addEventListener('change', ()=>renderHeat(dowSel.value, hourRange.value));
    hourRange.addEventListener('input', ()=>{ updateHourLabel(); renderHeat(dowSel.value, hourRange.value); });
    allHoursChk.addEventListener('change', ()=>renderHeat(dowSel.value, hourRange.value));

    // ───────── 5) 내 위치 지속 추적 + 근접 알림
    const hud=document.getElementById('hud'); let myMarker=null, accCircle=null;

    function updateMyLocation(lat, lon, acc, speed){
      const latlng=[lat,lon];

      // 내 위치 마커/정확도 원
      if(!myMarker) myMarker=L.marker(latlng).addTo(map).bindPopup('내 위치'); else myMarker.setLatLng(latlng);
      if(!accCircle) accCircle=L.circle(latlng,{radius:acc||10,weight:1,fillOpacity:.15}).addTo(map);
      else { accCircle.setLatLng(latlng); accCircle.setRadius(acc||10); }

      // 반경 표시(사용자 설정 반경)
      const rad = Number(radiusSel.value||100);
      if(!alertCircle) alertCircle = L.circle(latlng,{radius:rad, color:'#ff4d4f', weight:1, dashArray:'4 4', fillOpacity:0}).addTo(map);
      else alertCircle.setLatLng(latlng), alertCircle.setRadius(rad);

      // 따라가기
      map.setView(latlng, Math.max(map.getZoom(), 15));

      // HUD
      const accStr=(acc!=null)?`${Math.round(acc)} m`:'-';
      const spd=(speed!=null && !Number.isNaN(speed))?(speed*3.6):null;
      hud.textContent=`내 위치: ${lat.toFixed(6)}, ${lon.toFixed(6)} | 정확도: ${accStr}` + (spd!=null?` | 속도: ${spd.toFixed(1)} km/h`:``);

      // 근접 알림
      if(alertToggle.checked) checkProximity(lat, lon, rad, Number(thresInp.value||5));
    }

    // 근사거리 계산(빠르고 충분히 정확): 위도/경도 → 미터 단위 평면 근사
    function distanceMeters(lat1, lon1, lat2, lon2){
      const toRad = Math.PI/180;
      const phi = (lat1+lat2)/2 * toRad;
      const kx = 111320 * Math.cos(phi); // 경도→m
      const ky = 110540;                 // 위도→m
      const dx = (lon2 - lon1) * kx;
      const dy = (lat2 - lat1) * ky;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function checkProximity(lat, lon, radiusM, threshold){
      if(!activePoints || activePoints.length===0) return;
      // 포인트가 아주 많아도 반경 수백 m면 실측상 OK; 필요시 간단한 bbox로 먼저 걸러도 됨
      let cnt=0;
      const degLat = radiusM / 110540;
      const degLon = radiusM / (111320 * Math.cos(lat*Math.PI/180));
      const minLat = lat - degLat, maxLat = lat + degLat;
      const minLon = lon - degLon, maxLon = lon + degLon;

      for(const p of activePoints){
        const plat=p[0], plon=p[1];
        if(plat<minLat || plat>maxLat || plon<minLon || plon>maxLon) continue; // 빠른 1차 필터
        if(distanceMeters(lat,lon,plat,plon) <= radiusM){
          cnt++; if(cnt>=threshold) break;
        }
      }

      const now=Date.now();
      const cooldown=15000; // 15초 쿨다운
      if(cnt>=threshold && (now - lastAlertAt > cooldown)){
        lastAlertAt = now;
        triggerAlert();
      }
    }

    // 진동 + 짧은 경고 표시 + (가능하면) 비프음
    function triggerAlert(){
      // Vibrate
      if('vibrate' in navigator) { try{ navigator.vibrate([120,80,120]); }catch(e){} }
      // Visual banner
      alertBox.style.display='block';
      setTimeout(()=>{ alertBox.style.display='none'; }, 2500);
      // Beep (일부 브라우저는 사용자 제스처 이후에만 동작)
      try{
        const ctx = new (window.AudioContext||window.webkitAudioContext)();
        const o = ctx.createOscillator(); const g = ctx.createGain();
        o.type='sine'; o.frequency.value=880; o.connect(g); g.connect(ctx.destination);
        g.gain.setValueAtTime(0.0001, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime+0.02);
        o.start();
        g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+0.4);
        o.stop(ctx.currentTime+0.45);
      }catch(e){ /* 무음 fallback */ }
    }

    // 수동 테스트 버튼
    testBtn.addEventListener('click', triggerAlert);

    function handleGeoError(err){ console.warn('Geolocation error:',err); hud.textContent=`GPS 오류: ${err.message}`; }
    function startWatch(){
      if(!('geolocation' in navigator)){ hud.textContent='이 브라우저는 위치 서비스를 지원하지 않습니다.'; return; }
      navigator.geolocation.watchPosition(
        pos => { const {latitude,longitude,accuracy,speed}=pos.coords; updateMyLocation(latitude,longitude,accuracy,speed); },
        handleGeoError,
        { enableHighAccuracy:true, maximumAge:0, timeout:10000 }
      );
    }

    // ───────── 6) 시작
    function init(){
      hourLabel.textContent = (hourRange.value.padStart ? hourRange.value.padStart(2,'0') : ('0'+hourRange.value).slice(-2)) + '시';
      loadCSV();
      startWatch();
    }
    init();
  </script>
</body>
</html>
